<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Using the filesystem for illustration purposes - Alex Lawrence</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Using the filesystem for illustration purposes" />
<meta property="og:description" content="This post describes the approach of using the filesystem for illustrating the implementation of concepts related to persistence and messaging. Some of the explanations are put into the context of my book &ldquo;Implementing DDD, CQRS and Event Sourcing&rdquo;. The approach is compared to the alternatives of using existing technologies as well as providing pseudo in-memory implementations. At the end, the post outlines the most relevant benefits and implications.
The approach Apart from Node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.alex-lawrence.com/posts/using-the-filesystem-for-illustration-purposes/" />



<meta property="article:published_time" content="2020-12-29T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2020-12-29T00:00:00&#43;00:00"/>










<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Using the filesystem for illustration purposes"/>
<meta name="twitter:description" content="This post describes the approach of using the filesystem for illustrating the implementation of concepts related to persistence and messaging. Some of the explanations are put into the context of my book &ldquo;Implementing DDD, CQRS and Event Sourcing&rdquo;. The approach is compared to the alternatives of using existing technologies as well as providing pseudo in-memory implementations. At the end, the post outlines the most relevant benefits and implications.
The approach Apart from Node."/>
<link rel="stylesheet" type="text/css" media="screen" href="https://www.alex-lawrence.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.alex-lawrence.com/css/main.css" />
	<link rel="stylesheet" type="text/css" href="https://www.alex-lawrence.com/css/index.css" />
	<link rel="stylesheet" type="text/css" href="https://www.alex-lawrence.com/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://www.alex-lawrence.com/js/feather.min.js"></script>
	
	<script src="https://www.alex-lawrence.com/js/main.js"></script>
	<script src="https://www.alex-lawrence.com/js/index.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<base href="https://www.alex-lawrence.com/">
	<h1 class="site-title"><a href="https://www.alex-lawrence.com/">Alex Lawrence</a></h1>
	<div class="site-description"><h2>Full-Stack Developer, Technical Lead, Software Architect</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/alexlawrence" title="Github"><i data-feather="github"></i></a><a href="https://twitter.com/lx_lawrence" title="Twitter"><i data-feather="twitter"></i></a><a href="/posts/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Profile</a>
			</li>
			
			<li>
				<a href="/resume">Resume</a>
			</li>
			
			<li>
				<a href="/posts">Posts</a>
			</li>
			
			<li>
				<a href="/book">Book</a>
			</li>
			
			<li>
				<a href="/talks">Talks</a>
			</li>
			
			<li>
				<a href="/contact">Contact</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">Using the filesystem for illustration purposes</h1>
			
				<div class="meta">
					Posted at Dec 29, 2020 &mdash;
					Reading time: 6 minutes
				</div>
			
		</div>

		<div class="markdown">
			

<p>This post describes the approach of using the filesystem for illustrating the implementation of concepts related to persistence and messaging. Some of the explanations are put into the context of my book <a href="https://leanpub.com/implementing-ddd-cqrs-and-event-sourcing">&ldquo;Implementing DDD, CQRS and Event Sourcing&rdquo;</a>. The approach is compared to the alternatives of using existing technologies as well as providing pseudo in-memory implementations. At the end, the post outlines the most relevant benefits and implications.</p>

<h2 id="the-approach">The approach</h2>

<p>Apart from Node.js and JavaScript, my book does not explain or utilize specific frameworks or technologies. For all functionalities that require persistence or inter-process communication (IPC), it provides exemplary implementations that work with directly the filesystem. This includes Repositories, the Event Store, Read Model storages and an inter-process event distribution. The goal is to convey a deeper understanding of the concepts that are related to persistence and messaging. For production purposes, these implementations can be easily replaced with suitable technologies.</p>

<p>As example, the following snippet shows a basic variant of a generic filesystem-based Repository:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#ff79c6">class</span> FilesystemRepository {

  storageDirectory; #convertToData; #convertToEntity;

  constructor({storageDirectory, convertToData, convertToEntity}) {
    mkdirSync(storageDirectory, {recursive<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">true</span>});
    <span style="color:#8be9fd;font-style:italic">Object</span>.defineProperty(
      <span style="color:#ff79c6">this</span>, <span style="color:#f1fa8c">&#39;storageDirectory&#39;</span>, {value<span style="color:#ff79c6">:</span> storageDirectory, writable<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">false</span>});
    <span style="color:#ff79c6">this</span>.#convertToData <span style="color:#ff79c6">=</span> convertToData;
    <span style="color:#ff79c6">this</span>.#convertToEntity <span style="color:#ff79c6">=</span> convertToEntity;
  }

  <span style="color:#ff79c6">async</span> save(entity) {
    <span style="color:#ff79c6">const</span> data <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.#convertToData(entity);
    <span style="color:#ff79c6">await</span> writeFile(<span style="color:#ff79c6">this</span>.getFilePath(entity.id), JSON.stringify(data));
  }

  <span style="color:#ff79c6">async</span> load(id) {
    <span style="color:#ff79c6">const</span> dataString <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> readFile(<span style="color:#ff79c6">this</span>.getFilePath(id), <span style="color:#f1fa8c">&#39;utf-8&#39;</span>);
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">this</span>.#convertToEntity(JSON.parse(dataString));
  }

  getFilePath(id) {
    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>id) <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> <span style="color:#8be9fd;font-style:italic">Error</span>(<span style="color:#f1fa8c">&#39;invalid identifier&#39;</span>);
    <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">`</span><span style="color:#f1fa8c">${</span><span style="color:#ff79c6">this</span>.storageDirectory<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">/</span><span style="color:#f1fa8c">${</span>id<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">.json`</span>;
  }

}
</code></pre></div>
<p>The component can be used as base for specialized Repository components, such as the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#ff79c6">class</span> BookRepository <span style="color:#ff79c6">extends</span> FilesystemRepository {

  constructor({storageDirectory}) {
    <span style="color:#ff79c6">super</span>({storageDirectory,
      convertToData<span style="color:#ff79c6">:</span> entity =&gt; <span style="color:#6272a4">/* .. */</span>,
      convertToEntity<span style="color:#ff79c6">:</span> data =&gt; <span style="color:#ff79c6">new</span> Book(data)});
  }

  <span style="color:#ff79c6">async</span> findBooksPublishedAfter(date) {
    <span style="color:#ff79c6">const</span> files <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> readdir(<span style="color:#ff79c6">this</span>.storageDirectory);
    <span style="color:#ff79c6">const</span> ids <span style="color:#ff79c6">=</span> files.map(filename =&gt; filename.replace(<span style="color:#f1fa8c">&#39;.json&#39;</span>, <span style="color:#f1fa8c">&#39;&#39;</span>));
    <span style="color:#ff79c6">const</span> entities <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> <span style="color:#8be9fd;font-style:italic">Promise</span>.all(ids.map(id =&gt; <span style="color:#ff79c6">this</span>.load(id)));
    <span style="color:#ff79c6">return</span> entities.filter(book =&gt; book.publishingDate.getTime() <span style="color:#ff79c6">&gt;=</span> date.getTime());
  }

}
</code></pre></div>
<p>The class <code>FilesystemRepository</code> is a generic Repository component that can be used as base class for arbitrary Entity types. As constructor arguments, it expects a storage directory as well as custom converter operations. These operations define how Entities are converted to data representations and vice versa. The class <code>BookRepository</code> is an example for a specific Repository that implements the domain-specific query <code>findBooksPublishedAfter()</code>. Apart from a small utility function, the base Repository is identical to the initial version in my book.</p>

<p>Notifications of filesystem changes can be achieved with the Node.js utility <a href="https://nodejs.org/api/fs.html#fs_class_fs_fswatcher"><code>fs.FSWatcher</code></a>. This component utilizes native system mechanisms to watch for filesystem events, such as inotify on Linux. While it is a powerful abstraction, it is not guaranteed to work for all systems and scenarios. Specifically, it does not work with shared filesystems, such as NFS. Nevertheless, it is a good choice for the illustration of certain concepts, such as event stream subscriptions or inter-process event publishing.</p>

<p>The following is a simple example for inter-process communication using the filesystem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#ff79c6">if</span> (cluster.isMaster) cluster.fork();

<span style="color:#ff79c6">const</span> processType <span style="color:#ff79c6">=</span> cluster.isMaster <span style="color:#ff79c6">?</span> <span style="color:#f1fa8c">&#39;master&#39;</span> <span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#39;worker&#39;</span>;

<span style="color:#ff79c6">const</span> ownInbox <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">`inbox-</span><span style="color:#f1fa8c">${</span>processType<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>;
<span style="color:#ff79c6">await</span> mkdir(ownInbox, {recursive<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">true</span>});
fs.watch(ownInbox, <span style="color:#ff79c6">async</span> (event, filename) =&gt; {
  <span style="color:#ff79c6">if</span> (event <span style="color:#ff79c6">!==</span> <span style="color:#f1fa8c">&#39;rename&#39;</span>) <span style="color:#ff79c6">return</span>;
  <span style="color:#ff79c6">const</span> message <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> fs.promises.readFile(<span style="color:#f1fa8c">`</span><span style="color:#f1fa8c">${</span>ownInbox<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">/</span><span style="color:#f1fa8c">${</span>filename<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>, <span style="color:#f1fa8c">&#39;utf-8&#39;</span>);
  console.log(<span style="color:#f1fa8c">`message received in </span><span style="color:#f1fa8c">${</span>processType<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">: </span><span style="color:#f1fa8c">${</span>message<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>);
});

<span style="color:#ff79c6">await</span> <span style="color:#ff79c6">new</span> <span style="color:#8be9fd;font-style:italic">Promise</span>(resolve =&gt; setTimeout(resolve, <span style="color:#bd93f9">100</span>));
<span style="color:#ff79c6">const</span> otherInbox <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">`inbox-</span><span style="color:#f1fa8c">${</span>cluster.isMaster <span style="color:#ff79c6">?</span> <span style="color:#f1fa8c">&#39;worker&#39;</span> <span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#39;master&#39;</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>;
fs.promises.writeFile(<span style="color:#f1fa8c">`</span><span style="color:#f1fa8c">${</span>otherInbox<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">/</span><span style="color:#f1fa8c">${</span><span style="color:#8be9fd;font-style:italic">Date</span>.now()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>, <span style="color:#f1fa8c">`ping from </span><span style="color:#f1fa8c">${</span>processType<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>);
</code></pre></div>
<p>The code spawns two independent processes. Each of them starts with creating its own inbox directory. Then, a filesystem watcher is configured to output the content of newly added files. Afterwards, each process writes a file into the inbox directory of the other one. Executing the code will output two messages that are sent across processes. While this example uses the <code>cluster</code> module, the programs could also be spawned in any other way.</p>

<h2 id="why-not-specific-frameworks-or-technologies">Why not specific frameworks or technologies?</h2>

<p>The use of specific frameworks or technologies for illustrating concepts related to persistence or messaging has both advantages and disadvantages. One benefit is the possibility to provide production-ready code. Furthermore, it allows to explain the used technologies, if that is a goal. However, there are multiple disadvantages. The use of specific tools inherently seems like a recommendation. Also, the reader requires more experience compared to when utilizing the filesystem. Finally, many technologies introduce an overhead, both in setup and use.</p>

<p>As example, consider my book would be using PostgreSQL as storage technology for an Event Store. In order to provide executable example implementations, the database setup would need to be explained. Also, reading the according code would require to understand SQL. Generally, PostgreSQL is a suitable candidate for an Event Store. However, there are also many other fitting databases. As always, the right choice of technologies depends on the specific use case. Therefore, implicit recommendations can in fact be counterproductive.</p>

<h3 id="build-it-yourself-and-throw-it-away">Build it yourself and throw it away</h3>

<p>Attempting to build something yourself enables to gain a deep understanding of the associated concepts. With this approach, the goal is not to successfully build a production-grade functionality, but to learn as much as possible. In addition to a deep understanding of the concepts, one typically acquires the necessary knowledge to identify suitable existing technologies. Obviously, it is very subjective and generic to say that learning by building it yourself works well. Your individual experience may be different, of course.</p>

<p>For me personally, there were many occasions where this approach worked great. When I programmed with Turbo Pascal in my early adolescence, I tried to implement a 3D graphics engine. When I first worked as a freelancer, I built and used a small CMS, completely equipped with authentication and authorization. During my studies, I built a 2D physics engine in ActionScript/Flash. In the end, none of the projects were vastly successful. Nevertheless, my personal learning experience was second to none.</p>

<h2 id="why-not-a-pseudo-implementation">Why not a pseudo-implementation?</h2>

<p>Another possibility for illustrating certain concepts is to provide a pseudo-implementation, such as an in-memory storage. While this can work, it is ill-suited for concepts related to persistence and inter-process communication. There are many challenges an in-memory functionality can simply ignore, such as transactions. Of course, these aspects can be simulated in some way, but the resulting implementations are likely to feel very artificial. Also, there are some concepts that simply require actual persistence, such as persistent Read Model projections.</p>

<p>As example, consider a minimal in-memory variant of the previously shown Repository component:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#ff79c6">class</span> InMemoryRepository {

  #storage;

  constructor() {
    <span style="color:#ff79c6">this</span>.#storage <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Map();
  }

  save(entity) {
    <span style="color:#ff79c6">this</span>.#storage.set(entity.id, entity);
  }

  load(id) {
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">this</span>.#storage.get(id);
  }

}
</code></pre></div>
<p>The class <code>InMemoryRepository</code> is a Repository that stores Entities transiently. While its code is very short, it completely misses some crucial aspects. For one, it works synchronously, whereas actual persistence mechanisms are always asynchronous. Secondly, there is no data conversion, as the Map instance stores the actual objects. This practice can even lead to unexpected side effects, as the same reference objects are shared across all consumers. Overall, the class provides almost no abstraction over using a Map instance directly.</p>

<h2 id="all-the-glitters-is-not-gold">All the glitters is not gold</h2>

<p>Using the filesystem for illustrating concepts related to persistence or messaging can be beneficial, but also has implications. Ideally, it enables to convey detailed knowledge. Also, it avoids technology preferences, does not require additional experience and can prevent overhead. At the same time, utilizing the filesystem for complex topics can feel like re-inventing the squared wheel. In the worst case, it produces more overhead than using an existing technology. Still, for the examples in my book it proved itself useful.</p>

<p><a href="https://leanpub.com/implementing-ddd-cqrs-and-event-sourcing">Buy the book</a>
•
<a href="https://twitter.com/lx_lawrence/status/1343871960783187968">Discuss on Twitter</a></p>

		</div>

		<div class="post-tags">
			
				
			
		</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © 2020 Alex Lawrence |  <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>



<script>feather.replace()</script>
</body>
</html>
